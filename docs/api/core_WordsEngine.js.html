<!DOCTYPE html><html lang="en"> <head> <meta charset="utf-8"> <title>JSDoc: Source: core/WordsEngine.js</title> <script src="../prettify.ed0c630f.js"> </script> <script src="../lang-css.9fdb3da7.js"> </script> <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--> <link type="text/css" rel="stylesheet" href="../prettify-tomorrow.01e2caea.css"> <link type="text/css" rel="stylesheet" href="../jsdoc-default.c9519cdb.css"> </head> <body> <div id="main"> <h1 class="page-title">Source: core/WordsEngine.js</h1> <section> <article> <pre class="prettyprint source linenums"><code>/* KokoaNLP
Copyright (C) 2018  Seungjae Park

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/>. */

const fs = require('fs');

const Engine = require('./Engine');

// Subtext extractor cache
const subtextRecipes = new Map();

/**
 * Extracts subtexts from the given chunk.
 * @private
 * @param {string} chunk The chunk to extract subtexts.
 * @returns {Array.&lt;Array.&lt;string>>} Subtexts of the chunk.
 */
const extractSubtexts = (chunk) => {
  if (subtextRecipes.has(chunk)) {
    return subtextRecipes.get(chunk);
  }
  const subtexts = [];
  const chars = chunk;
  for (let i = 0, len = chars.length; i &lt;= len; i += 1) {
    subtexts.push([chars.slice(0, i), chars.slice(i).split('').reverse().join('')]);
  }
  subtextRecipes.set(chunk, subtexts);
  return subtexts;
};

/**
 * Class representing a word extracting engine.
 */
class WordsEngine extends Engine {
  /**
   * Creates words engine instance.
   * @param {Object} [model] Words engine model.
   * @param {Array.&lt;Array.&lt;string|number>>} [model.originalFrequencies]
   *  How many times words appear.
   * @param {Array.&lt;Array.&lt;string|number>>} [model.originalScores] Words cohension n-gram value.
   * @param {Array.&lt;Array.&lt;string|number>>} [model.reversedFrequencies]
   *  How many times reversed words appear.
   * @param {Array.&lt;Array.&lt;string|number>>} [model.reversedScores]
   *  Reversed words cohension n-gram value.
   */
  constructor({
    originalFrequencies, originalScores, reversedFrequencies, reversedScores,
  } = {}) {
    super();
    this.originalFrequencies = new Map(originalFrequencies);
    this.originalScores = new Map(originalScores);
    this.reversedFrequencies = new Map(reversedFrequencies);
    this.reversedScores = new Map(reversedScores);
  }

  /**
   * Loads words engine instance from the given model.
   * @param {string} file Words engine model file path.
   * @returns {WordsEngine} Words engine instance.
   */
  static load(file) {
    if (fs.existsSync(file)) {
      const originalFrequencies = [];
      const originalScores = [];
      const reversedFrequencies = [];
      const reversedScores = [];
      let isOriginal = true;
      fs.readFileSync(file).toString().split('\n').forEach((value) => {
        if (value === '---') {
          isOriginal = false;
        } else {
          const [text, frequency, score] = value.split(',');
          if (isOriginal) {
            originalFrequencies.push([text, Number(frequency)]);
            originalScores.push([text, Number(score)]);
          } else {
            reversedFrequencies.push([text, Number(frequency)]);
            reversedScores.push([text, Number(score)]);
          }
        }
      });
      return new WordsEngine({
        originalFrequencies,
        originalScores,
        reversedFrequencies,
        reversedScores,
      });
    }
    return null;
  }

  /**
   * Returns how many times given word appears.
   * @param {string} word The word to be counted.
   * @return {number} How many times given word appears.
   */
  getFrequency(word) {
    const { originalFrequencies } = this;
    return originalFrequencies.has(word) ? originalFrequencies.get(word) : 0;
  }

  /**
   * Extracts a word from the given chunk.
   * @param {string} chunk The chunk to be analyzed. (must be hangul)
   * @returns {?string} A word from the given chunk.
   */
  run(chunk) {
    const { originalScores, reversedScores } = this;
    const subtexts = extractSubtexts(chunk);
    const scores = subtexts.map(([originalSubtext, reversedSubtext]) => [
      originalSubtext,
      reversedSubtext,
      (originalScores.has(originalSubtext) ? originalScores.get(originalSubtext) : 0.01),
      (reversedScores.has(reversedSubtext) ? reversedScores.get(reversedSubtext) : 0.01),
    ]);
    for (let i = 0; i &lt; 3; i += 1) {
      let candidates;
      if (i === 0) {
        candidates = scores.filter(([, , originalScore, reversedScore], index, array) => {
          const nextOriginalScore = index === array.length - 1 ? 0 : array[index + 1][2];
          const previousReversedScore = index === 0 ? 0 : array[index - 1][3];
          return originalScore >= nextOriginalScore &amp;&amp; reversedScore >= previousReversedScore;
        });
      } else if (i === 2) {
        candidates = scores.filter(([, , originalScore], index, array) => {
          const nextOriginalScore = index === array.length - 1 ? 0 : array[index + 1][2];
          return originalScore >= nextOriginalScore;
        });
      } else if (i === 1) {
        candidates = scores.filter(([, , , reversedScore], index, array) => {
          const previousReversedScore = index === 0 ? 0 : array[index - 1][3];
          return reversedScore >= previousReversedScore;
        });
      }
      if (candidates.length > 0) {
        const word = candidates.map(([originalSubtext, , originalScore]) => [
          originalSubtext,
          originalScore + (originalSubtext.length / 10000), // Prevents returning empty string.
        ]).reduce((r, a) => (a[1] > r[1] ? a : r))[0];
        return word;
      }
    }
    return null;
  }

  /**
   * Saves words engine instance as a file.
   * @param {string} file Words engine model file path.
   */
  save(file) {
    const {
      originalFrequencies, originalScores, reversedFrequencies, reversedScores,
    } = this;
    const content = [];
    originalFrequencies.forEach((frequency, text) => {
      content.push([text, frequency, originalScores.get(text)].join(','));
    });
    content.push('---');
    reversedFrequencies.forEach((frequency, text) => {
      content.push([text, frequency, reversedScores.get(text)].join(','));
    });
    fs.writeFileSync(file, content.join('\n'));
  }

  /**
   * Trains the given chunks.
   * @param {Array.&lt;string>} chunks The chunks to be trained. (must be hangul)
   */
  train(chunks) {
    const { originalFrequencies, reversedFrequencies } = this;
    const chunkArr = chunks.map(extractSubtexts);
    // Extract all words and count how many words appear.
    for (let i = 0, len = chunkArr.length; i &lt; len; i += 1) {
      const subtexts = chunkArr[i];
      if (subtexts.length > 2) { // Ignore one letter words.
        for (let j = 0, len2 = subtexts.length; j &lt; len2; j += 1) {
          const [originalSubtext, reversedSubtext] = subtexts[j];
          if (originalFrequencies.has(originalSubtext)) {
            originalFrequencies.set(originalSubtext, originalFrequencies.get(originalSubtext) + 1);
          } else {
            originalFrequencies.set(originalSubtext, 1);
          }
          if (reversedFrequencies.has(reversedSubtext)) {
            reversedFrequencies.set(reversedSubtext, reversedFrequencies.get(reversedSubtext) + 1);
          } else {
            reversedFrequencies.set(reversedSubtext, 1);
          }
        }
      }
    }
  }

  /** Updates calculated cohension n-gram value for each word. */
  update() {
    const {
      originalFrequencies, originalScores, reversedFrequencies, reversedScores,
    } = this;
    originalFrequencies.forEach((frequency, subtext, frequencies) => {
      if (subtext.length === 0) {
        originalScores.set(subtext, 0);
      } else if (subtext.length === 1) {
        originalScores.set(subtext, 0);
      } else {
        const exp = 1 / subtext.length;
        originalScores.set(subtext, (frequency / frequencies.get(subtext[0])) ** exp);
      }
    });
    reversedFrequencies.forEach((frequency, subtext, frequencies) => {
      if (subtext.length === 0) {
        reversedScores.set(subtext, 0);
      } else if (subtext.length === 1) {
        reversedScores.set(subtext, 0);
      } else {
        const exp = 1 / subtext.length;
        reversedScores.set(subtext, (frequency / frequencies.get(subtext[0])) ** exp);
      }
    });
  }
}

module.exports = WordsEngine;
</code></pre> </article> </section> </div> <nav> <h2><a href="../api/index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="../api/Kokoa.html">Kokoa</a></li><li><a href="../api/Model.html">Model</a></li><li><a href="../api/SpacingEngine.html">SpacingEngine</a></li><li><a href="../api/WordsEngine.html">WordsEngine</a></li></ul> </nav> <br class="clear"> <footer> Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Jun 27 2018 01:03:38 GMT+0900 (Korean Standard Time) </footer> <script>prettyPrint();</script> <script src="../linenumber.1c80b311.js"> </script> </body> </html>